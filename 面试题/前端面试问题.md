# 前端面试问题

## 一个 tcp 连接能发几个 http 请求？

如果是HTTP 1.0 版本协议，一般情况下，不支持长连接，因此在每次请求发送完毕之后，TCP连接即会断开，因此一个TCP发送一个HTTP请求，但是有一种情况可以将一条TCP连接保持在活跃状态，那就是通过`Connection`和`Keep-Alive`首部，在请求头带上` Connection: Keep-Alive` ，并且可以通过`Keep-Alive` 通用首部中指定的，用逗号分隔的选项调节keep-alive的行为，如果客户端和服务端都支持，那么其实也可以发送多条，不过此方式也有限制，可以关注《HTTP 权威指南》4.5.5 节对于Keep-Alive连接的限制和规则；

而如果是HTTP 1.1 版本协议，支持了长连接，因此只要TCP连接不断开，便可以一直发送HTTP请求，持续不断，没有上限；

同样，如果是HTTP 2.0 版本协议，支持多用复用，一个TCP连接是可以并发多个HTTP请求的，同样也是支持长连接，因此只要不断开TCP的连接，HTTP请求数也是可以没有上限地持续发送，



简单来说：

HTTP/1.0 :一个tcp连接只能发一个http请求。每次服务端返回响应后TCP连接会断开。

HTTP/1.1: 默认开启Connection: keep-alive，一个TCP连接可以发多个http请求，但是多个请求是串行执行。（注意区别TCP的keep-alive）

HTTP/2: 引入了多路复用技术 和二进制分帧，同个域名下的请求只需要占用一个 TCP 连接，请求和响应是并行执行。



## Virtual Dom 的优势在哪里？

虚拟Dom的优势在哪里？

Virtual Dom 的优势」其实这道题目面试官更想听到的答案不是上来就说「直接操作/频繁操作 DOM 的性能差」，如果 DOM 操作的性能如此不堪，那么 jQuery 也不至于活到今天。所以面试官更想听到 VDOM 想解决的问题以及为什么频繁的 DOM 操作会性能差。

首先我们需要知道：

DOM 引擎、JS 引擎 相互独立，但又工作在同一线程（主线程）
JS 代码调用 DOM API 必须 挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，
引擎间切换的单位代价将迅速积累若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会引起更大的性能消耗。

其次是 VDOM 和真实 DOM 的区别和优化：

1. 虚拟 DOM 不会立马进行排版与重绘操作
2. 虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多DOM节点排版与重绘损耗
3. 虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部





# 函数形参与实参

```js
function test (a, b) {
  arguments[2] = 3;
  console.log(arguments.length); // -> 2
  console.log(arguments[2]); // -> 3
}

test(1, 2);
console.log(test.length); // -> 2

```

答案是 2 3 2  --关键知识点 argumesnts --类数组

原因：argumesnts是是一个类数组，并不是一个数组，但除了length属性和索引元素之外没有任何`Array`属性，实际上arguments是一个对象来的

因此`arguments[2]=3`该操作实际上是给`arguments`添加了一个键值对，键名是2，键值是3。并不会为`length`属性加一

```js
Arguments(2) [1, 2, 2: 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]js
//实际上的内容
```

所以第一次打印的是2 。第二次打印是直接获取的实参列表键名为2的值，所以直接打印3。第三次打印是在函数外部打印函数的`length`属性，函数的`length`属性就是函数的形参个数，所以打印2



# ['1', '2', '3'].map(parseInt)的结果是什么？

```
先说结果：
['1', NaN, NaN]
为什么不是['1', '2', '3']呢，下面开始分析
复制代码
```

- map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
- map() 方法按照原始数组元素顺序依次处理元素。

map(parseInt)其实是：

```
map(function(item, index){
    return parseInt(item, index);
})
```

即依次运行的是：

```
parseInt('1', 0);
parseInt('2', 1);
parseInt('3', 2);
```

### parseInt的用法

- parseInt(string, radix) 函数可解析一个字符串，并返回一个整数。
- 当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。
- radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。

所以： parseInt('1', 0);//'1' parseInt('2', 1);//NaN parseInt('3', 2);//NaN，由于2进制中没有3



# 对象引用的问题




```js
function changeObjProperty(o) {
    o.siteUrl = "http://www.baidu.com";
    o = new Object();
    o.siteUrl = "http://www.google.com";
} 
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl);
```

此题咋看小问题，其实暗藏玄机。 先说答案：

```js
console.log(webSite.siteUrl);//"http://www.baidu.com"
```

复盘如下：

```js
function changeObjProperty(o) {
    //o是形参，对象的引用，依旧指向原地址，相当于 var o = webSite;赋值改变对象的属性
    o.siteUrl = "http://www.baidu.com";
    //变量o指向新的地址 以后的变动和旧地址无关，题目打印的是外部webSite.siteUrl
    o = new Object();
    o.siteUrl = "http://www.google.com";
}
复制代码
```

将题目改成如下：

```js
function changeObjProperty(o) {
    o.siteUrl = "http://www.baidu.com";
    o = new Object();
    o.siteUrl = "http://www.google.com";
    return o;
} 
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl);
let newSite = changeObjProperty(webSite);
console.log(newSite.siteUrl);
```

此时打印结果如下：

```
console.log(webSite.siteUrl);//"http://www.baidu.com"
console.log(newSite.siteUrl);//"http://www.google.com"
```




# 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 

2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;

 3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 

4、进行HTTP协议会话，客户端发送报头(请求报头); 

5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 

6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;

 7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 

8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 

9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;

 10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。

